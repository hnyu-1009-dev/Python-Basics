# ============================================================================================================
# 一、使用import进行模块引入的底层逻辑
# 💡💡💡💡💡💡
# 1️⃣  当执行 import my_module 时：
#      → Python 会去 sys.path 中查找 my_module.py 文件。
#
# 2️⃣  找到文件后，Python 会：
#      → 创建一个新的模块对象（module object）。
#      → 执行这个模块中的所有顶层语句（即没有缩进的部分）。
#
# 3️⃣  执行结束后，Python 会：
#      → 把这个模块对象放入 sys.modules 缓存中。
#      → 在当前命名空间中创建名字 my_module，指向这个模块对象。
# 💡 换句话说：import 不仅仅是“引入名字”，它实际上会“运行一遍”目标模块的代码文件。
# ============================================================================================================
# 对于自定义模块my_module的导入测试
# import my_module	                                      my_module.test_function1()   命名空间清晰，防止冲突	每次调用要加前缀
# from my_module import test_function1, test_function2	  test_function1()	           导入精准，书写简洁	    容易与同名函数冲突
# from my_module import *	                              test_function1()	           快捷（导入全部）	    不推荐：污染命名空间，不易维护
# import my_module as mm	                              mm.test_function1()	       短别名好看	            仍需前缀，但更简洁
# from my_module import test_function1 as f1	          f1()	                       自定义别名	            适合解决命名冲突
# ------------------------------------------------------------------------------------------------------------
# 第一种方式：使用import语句导入模块
import my_module

# 调用模块中的函数
# 打上断点会发现，运行这个代码时，会直接跳转到my_model.py文件中，
# 并停在test_function1函数的第一行，并传入参数10和20。
# 在函数执行完毕后，程序会返回到user_my_model.py文件中继续执行。
my_module.test_function1(10, 20)
# ------------------------------------------------------------------------------------------------------------
# 第二种方式：使用from语句导入模块
# 这种方式可以省略了模块的前缀，直接使用函数名调用模块中的函数
# 这种方式可以一次性到如多个模块
# 这种方式也可以起别名，但是只有在调用单个函数的时候适用
from my_module import test_function1, test_function2

test_function1(10, 20)
test_function2(10, 20)
# ------------------------------------------------------------------------------------------------------------
# 第三种方式：使用as语句给模块起别名
# 这种方式的运行方式与上面的运行方式相同，但是可以自己简化模块的名称
import my_module as mm

mm.test_function1(10, 20)
# ------------------------------------------------------------------------------------------------------------
# 第四种方式：使用sys模块动态导入模块
import sys

sys.path.append('/03_modules_and_exceptions')
import my_module as mm

# 调用模块中的函数
mm.test_function1(10, 20)
# ============================================================================================================
# 二、使用__builtin__模块
# 每个python文件在创建时都会导入一个内置模块__builtin__，它包含了python的内置函数和数据类型。
# 因此，在自定义模块中，我们可以直接使用__builtin__模块中的函数和数据类型。
# ------------------------------------------------------------------------------------------------------------
# builtins 模块结构图（部分内容）
# ------------------------------------------------------------------------------------------------------------
# builtins
# ├── 常量：
# │   ├── True
# │   ├── False
# │   └── None
# │
# ├── 常用类型：
# │   ├── int, float, str, bool, list, tuple, set, dict
# │   ├── object, type, complex, range
# │   └── bytes, bytearray, memoryview
# │
# ├── 常用函数：
# │   ├── print(), input(), len(), sum(), max(), min()
# │   ├── abs(), round(), pow(), range()
# │   ├── isinstance(), issubclass()
# │   ├── id(), dir(), vars(), locals(), globals()
# │   ├── eval(), exec(), compile()
# │   └── open(), help(), hash(), sorted(), enumerate()
# │
# ├── 异常类：
# │   ├── BaseException
# │   ├── Exception
# │   ├── TypeError, ValueError, IndexError, KeyError, NameError
# │   ├── IOError, OSError, ZeroDivisionError, ImportError
# │   └── KeyboardInterrupt, SystemExit
# │
# └── 其他：
#     ├── __build_class__
#     ├── __import__
#     └── NotImplemented, Ellipsis
# ------------------------------------------------------------------------------------------------------------
# 导入builtins模块（正常默认导入）
# 当 Python 解释器启动时，会自动执行：
import builtins

# 查看所有内置对象名称
# dir可以查看模块的内置变量
print(dir(builtins))

# 获取内置函数对象
print(builtins.print)  # <built-in function print>
print(builtins.len)  # <built-in function len>
print(builtins.str)  # <class 'str'>

# 可以“修改”或“扩展” builtins（⚠️ 不建议）
# 添加一个新的全局函数（谨慎使用！）
# def greet(name):
#     print(f"Hello, {name}!")
#
#
# builtins.greet = greet  # 注册到 builtins 中
#
# # 现在在任意模块中都能直接使用：
# greet("World")  # ✅ Hello, World!
# ============================================================================================================
# 三、__name__变量 和 __main__模块
# 1. __name__变量
#    - 该变量在模块被导入时，值为模块的名称（文件名）。
#    - 该变量在模块被直接运行时，值为“__main__”。
print("__name__:", my_module.__name__)
# 2. __main__模块
#    - 当一个模块被直接运行时，它会创建一个新的模块对象，并将其放入 sys.modules 缓存中。
#    - 这个模块的名称就是“__main__”。
#    - 因此，在模块中，可以通过判断 __name__ == "__main__" 来判断当前模块是否为主模块。
# __all__变量
#    - 该变量用于控制模块的导入行为。
#    - 如果模块中定义了 __all__ 变量，那么它的值是一个列表，表示模块中哪些成员可以被直接导入。
#    - 如果 __all__ 变量不存在，那么模块中的所有成员都可以被直接导入。
# __all__只能对from语句起作用，对import语句无效。
# 因此，如果想使用__all__，必须使用from语句导入模块。
# from my_module import *
# my_model.test_function3(10, 20)
# ============================================================================================================
# 四、其他内置变量
# 1. __file__   当前文件路径
# 作用：返回当前 Python 脚本的完整路径（含文件名）
print("当前文件路径:", __file__)


# 注意：在交互式解释器中运行（例如 IDLE 或 Jupyter）时，__file__ 可能不存在
# ------------------------------------------------------------------------------------------------------------
# 3. __doc__   模块或函数的文档字符串
def add(a, b):
    """返回两个数的和"""
    return a + b


# 打印函数文档
print("add 函数的文档:", add.__doc__)


# 输出: 返回两个数的和
# ------------------------------------------------------------------------------------------------------------
# 4. __dict__   对象的属性字典
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age


p = Person("Alice", 22)

# 查看对象属性字典（以字典形式返回）
print("Person 实例的属性字典:", p.__dict__)

# 查看类的属性字典（包括方法）
print("Person 类的属性字典:", Person.__dict__)

# ------------------------------------------------------------------------------------------------------------

# 5. __module__   返回类或函数所在模块名

print("Person 类定义所在模块:", Person.__module__)
print("add 函数定义所在模块:", add.__module__)
# 在当前脚本中定义的，通常返回 "__main__"
# ------------------------------------------------------------------------------------------------------------
# 6. __class__   查看实例所属的类
print("p 的类型（所属类）:", p.__class__)


# 输出: <class '__main__.Person'>
# ------------------------------------------------------------------------------------------------------------
# 7. __bases__   查看类的父类
class Animal:
    pass


class Dog(Animal):
    pass


print("Dog 的父类:", Dog.__bases__)


# 输出: (<class '__main__.Animal'>,)
# ------------------------------------------------------------------------------------------------------------
# 8. __annotations__   存储类型注解
def greet(name: str, age: int) -> str:
    return f"你好 {name}, 你 {age} 岁了。"


print("greet 函数的类型注解:", greet.__annotations__)
# 输出: {'name': <class 'str'>, 'age': <class 'int'>, 'return': <class 'str'>}
# ------------------------------------------------------------------------------------------------------------
# 9. __builtins__   内置模块（包含所有内置函数和异常）
# __builtins__ 是一个字典或模块，包含所有 Python 内置的函数、类型、异常等
print("内置函数列表（部分）:", dir(__builtins__)[:10])
# 示例输出: ['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BaseExceptionGroup', ...]
# -----------------------------------------------------------------------------------------------------------
# 10. __package__   当前模块的包名
# 如果该文件属于某个包（被 import 时），__package__ 表示包名
# 如果直接运行脚本，则 __package__ 的值为 None
print("当前模块所属包:", __package__)
# ============================================================================================================
